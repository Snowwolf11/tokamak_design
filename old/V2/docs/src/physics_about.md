docs/src/physics_about.md
========================
Pass A: Module contract for `src/.../physics/` (expanded: physics + algorithms)

Date: 2026-01-16

Scope
-----
This document describes the `src/.../physics` subfolder at a *design,
physics, and numerical-algorithm* level.

It keeps **everything already documented** and extends it with:
  • deeper discussion of the underlying physics
  • explicit numerical algorithms (discretization, linear algebra, iteration)
  • rationale for design choices and simplifications

Focus:
  • what physics is implemented today (fixed-boundary GS, vacuum fields)
  • how it is solved numerically
  • what assumptions are baked in
  • what is intentionally deferred


================================================================================
Physics layer philosophy (expanded)
================================================================================

The physics layer answers:

  “Given geometry, sources, and assumptions, what magnetic configuration results?”

The key architectural decision is that **physics is explicit, inspectable,
and modular**, rather than hidden behind monolithic solvers.

Design principles (revisited)
-----------------------------
1) Statelessness
   - No hidden iteration counters
   - No implicit coupling between calls
   - Repeatable results for identical inputs

2) Algorithmic clarity over performance
   - Direct sparse solvers over opaque optimized libraries
   - Explicit FD stencils over autogenerated operators
   - Physical correctness prioritized over speed (for now)

3) Incremental realism
   - Start with vacuum + fixed-boundary equilibria
   - Add nonlinearity, coupling, and free-boundary effects later
   - Each step should be independently testable

This philosophy mirrors classic equilibrium code development
(e.g. early GS solvers) rather than modern black-box tools.


================================================================================
greens.py — Magnetic Green’s functions (deep dive)
================================================================================

Physical background
-------------------
In axisymmetric magnetostatics, the poloidal flux ψ generated by a toroidal
current density j_φ satisfies:

  Δ* ψ = - μ₀ R j_φ

For a *filamentary circular loop* carrying current I at (Rc, Zc),
the source term is a delta-function in (R,Z).

The resulting ψ can be written analytically using elliptic integrals:
  • K(k) — complete elliptic integral of the first kind
  • E(k) — complete elliptic integral of the second kind

where the modulus k depends on the geometry:

  k² = 4 R Rc / [(R + Rc)² + (Z - Zc)²]

This is a classical result from axisymmetric magnetostatics.

Algorithmic implementation
--------------------------
- ψ(R,Z) is evaluated pointwise on the grid
- For each grid point:
    1) compute geometric factors
    2) evaluate elliptic integrals
    3) assemble ψ using analytic formula
- No discretization of PDEs is involved here

Numerical characteristics:
--------------------------
- Accuracy limited primarily by floating-point precision and elliptic evaluation
- Singular behavior near the filament is handled analytically (logarithmic terms)
- Computational cost scales as O(NR × NZ × Ncoils)

Design rationale:
-----------------
- This method avoids solving Poisson problems for vacuum fields
- Produces smooth, noise-free ψ fields
- Ideal for precomputing Green’s functions per ampere

Role in larger algorithms:
--------------------------
- Forms the *linear response* of ψ to coil currents
- Enables fast recombination:
    ψ_vac = Σ I_k G_k
- This linearity is crucial for optimization and fitting later


================================================================================
gs_operator.py — Discrete Grad–Shafranov operator (deep dive)
================================================================================

Physics background
------------------
The Grad–Shafranov operator in cylindrical coordinates is:

  Δ* ψ = R ∂/∂R (1/R ∂ψ/∂R) + ∂²ψ/∂Z²

This operator is elliptic and self-adjoint under appropriate inner products.

Discretization strategy
-----------------------
- Uniform grid in R and Z
- Second-order central finite differences
- Operator written in conservative form to preserve symmetry

Finite-difference stencil (interior point):
--------------------------------------------
Let ΔR, ΔZ be grid spacings.

Radial part:
  R ∂/∂R (1/R ∂ψ/∂R)
≈ (1/ΔR²) [ (R_{i+1/2}/R_i)(ψ_{i+1} - ψ_i)
          - (R_{i-1/2}/R_i)(ψ_i - ψ_{i-1}) ]

Vertical part:
  ∂²ψ/∂Z² ≈ (ψ_{j+1} - 2ψ_j + ψ_{j-1}) / ΔZ²

Numerical properties:
---------------------
- Second-order accurate in both R and Z
- Sparse banded structure
- Well-conditioned for reasonable aspect ratios

Sparse matrix assembly:
-----------------------
- Each interior grid point → one row
- At most 5 non-zero entries per row
- Stored in CSR format for efficient solves

Boundary treatment:
-------------------
- Boundary points are *excluded* from the operator
- Dirichlet values are enforced externally via RHS modification

Design rationale:
-----------------
- Explicit assembly allows easy debugging and inspection
- Makes later extensions (nonuniform grids, higher order) straightforward


================================================================================
gs_profiles.py — Plasma current profiles (deep dive)
================================================================================

Physics background
------------------
In GS theory, the toroidal current density is:

  j_φ(R,Z) = (1/μ₀ R) [ R² p'(ψ) + F(ψ) F'(ψ) ]

In this codebase:
  • pressure and poloidal current functions are parameterized directly
  • ψ-dependence is explicit and analytic

Implemented profile philosophy
------------------------------
- Profiles are functions of *normalized flux*:
    ψ̂ = (ψ - ψ_axis) / (ψ_boundary - ψ_axis)
- Enforces:
    ψ̂ = 0 at axis
    ψ̂ = 1 at LCFS

Typical forms:
--------------
- Polynomial:
    j_φ ∝ (1 - ψ̂)^α
- Power-law with smooth cutoff
- Scaled to enforce a target total plasma current

Algorithmic steps:
------------------
1) Normalize ψ
2) Evaluate profile function pointwise
3) Zero current outside LCFS
4) Scale amplitude to satisfy Ip constraint

Numerical considerations:
-------------------------
- No iteration yet: profile uses *previous* ψ
- This makes the fixed-boundary problem linear
- Nonlinear iteration deferred to future versions

Design rationale:
-----------------
- Keeps solver linear and robust
- Provides a clean hook for nonlinear iteration later


================================================================================
gs_solve_fixed.py — Fixed-boundary GS solver (deep dive)
================================================================================

Mathematical problem
--------------------
Solve inside a prescribed LCFS:

  Δ* ψ_plasma = - μ₀ R j_φ(ψ_total)

with:
  ψ_total = ψ_vac + ψ_plasma
  ψ_total|_boundary = ψ_boundary (constant)

Algorithmic structure
---------------------
This is currently a *single linear solve*:

1) Identify interior points:
   - Use plasma boundary polyline
   - Mask grid points inside LCFS

2) Assemble linear system:
   - L ψ_plasma = RHS
   - L from gs_operator
   - RHS from current profile evaluated on ψ_vac

3) Apply Dirichlet BCs:
   - Boundary ψ is enforced by modifying RHS
   - No ghost points required

4) Solve:
   - Direct sparse solve (scipy.sparse.linalg.spsolve)

5) Reconstruct ψ_total:
   - ψ_total = ψ_vac + ψ_plasma

Numerical properties:
---------------------
- Linear, elliptic PDE
- Guaranteed convergence (single solve)
- Computational cost dominated by sparse solve

Limitations (explicit):
-----------------------
- No self-consistent iteration of j_φ(ψ_total)
- LCFS is fixed and not coupled to solution
- No X-points or separatrices

Why this is still valuable:
---------------------------
- Provides a clean baseline equilibrium
- Ideal for regression testing
- Serves as a stepping stone to free-boundary GS


================================================================================
fields.py — Field reconstruction (deep dive)
================================================================================

Physics relations
-----------------
Given ψ(R,Z):

  B_R = - (1/R) ∂ψ/∂Z
  B_Z =   (1/R) ∂ψ/∂R

Numerical differentiation:
--------------------------
- Second-order central differences
- One-sided differences at boundaries
- Division by R handled explicitly (R>0 guaranteed by geometry)

Algorithmic notes:
------------------
- Differentiation is local and cheap
- Noise-free ψ → stable B fields
- No filtering or smoothing applied

Use cases:
----------
- Diagnostics
- Plotting
- Derived quantity calculation
- Not used in solver loop


================================================================================
derived.py — Derived quantities (deep dive)
================================================================================

Purpose
-------
Translate ψ and B into physically meaningful diagnostics.

Examples (implemented / planned):
---------------------------------
- Magnetic axis:
    min(ψ) search with local interpolation
- ψ at boundary:
    interpolation of ψ along LCFS polyline
- Flux surface geometry:
    contours of ψ

Numerical techniques:
---------------------
- Bilinear interpolation
- Contour finding on structured grids
- Simple root finding / minimization

Design philosophy:
------------------
- Derived quantities are *diagnostic*, not controlling
- Accuracy sufficient for engineering interpretation
- Not part of the equilibrium solve loop


================================================================================
What remains to be implemented (expanded)
================================================================================

Free-boundary Grad–Shafranov
----------------------------
Requires:
  • plasma-vacuum coupling
  • LCFS not known a priori
  • iteration loop:
      guess LCFS → solve GS → update LCFS → repeat

Numerical implications:
-----------------------
- Nonlinear problem
- Requires:
    • outer iteration loop
    • possibly under-relaxation
    • coil current response matrices
- Boundary conditions applied at vessel or infinity

Expected algorithmic structure:
-------------------------------
1) Start from fixed-boundary equilibrium
2) Compute normal field at plasma edge
3) Adjust LCFS position or coil currents
4) Iterate until force balance satisfied

Profile nonlinearity
--------------------
Future extension:
  • j_φ depends on ψ_total
  • Requires Picard or Newton iteration
  • Operator rebuilt or RHS updated per iteration

Performance considerations:
---------------------------
- Direct solves may become expensive
- Krylov solvers + preconditioners likely needed
- Multigrid is a possible future upgrade


================================================================================
Bottom line
================================================================================

The physics layer is:
  • physically sound
  • numerically explicit
  • deliberately conservative

It provides a **correct, inspectable foundation** for:
  • equilibrium development
  • optimization
  • future free-boundary extensions

This is exactly the right level of sophistication for the current stage of the project.
