# ============================================================
# solver.yaml
# ------------------------------------------------------------
# Numerical settings for:
# - fixed-boundary GS solve
# - free-boundary outer iterations
# - coil fitting / regularization
# ============================================================

meta:
  name: "default_solver_settings"
  schema_version: "0.1"

fixed_boundary_gs:
  # Nonlinear solve settings
  max_picard_iter: 80
  tol_rel_change: 1.0e-6       # convergence on psi update
  under_relaxation: 0.4        # omega in psi <- (1-ω)psi_old + ω psi_new

  # Linear solver settings
  linear_solver: "spsolve"     # "spsolve" (direct) or "cg" (iterative)
  cg_tol: 1.0e-10
  cg_max_iter: 5000

  # Boundary enforcement
  boundary_condition: "dirichlet"
  psi_lcfs: 1.0

  # Mask/boundary extraction
  mask_method: "point_in_polygon"  # stable and easy
  boundary_grid_snap: true         # snap boundary points to nearest grid nodes (v1)

free_boundary:
  # Outer iteration settings
  max_outer_iter: 40
  tol_lcfs_change: 2.0e-3       # relative change measure for boundary movement
  tol_Ip_rel_change: 1.0e-3         # relative change in Ip between iterations
  under_relax_lcfs: 0.6         # relax boundary updates to avoid oscillations

  # LCFS contour selection
  lcfs_selector: "largest_area"   #"largest_area"/"enclosing_axis"
  lcfs_resample_points: 360

  # Optional safety: keep LCFS inside vessel by clipping/penalty (v1 just detect)
  detect_wall_intersections: true

coil_fit:
  method: "contour_qp"          # boundary_value | contour | contour_qp  (fit type; contour_qp recommended)
  reg_lambda: 1.0e-6            # ridge strength (bigger -> smaller currents, worse fit)
  boundary_fit_points: 180      # int | null  (downsample boundary for speed/robustness)
  weight_by_coil_limits: true   # true/false  (solve in x=I/Imax for fair scaling)
  enforce_bounds: true          # true/false  (enforce |x|<=1 or |I|<=Imax)
  bounds_method: "active_set"   # metadata only (stored for provenance)

  psi_ref:  1.0                 # float (contour methods: enforce mean(psi_boundary)=psi_ref; avoid trivial I=0; if not given -> psi_ref = psi_boundary)
  constraint: "mean"            # mean  (contour constraint type; v1 supports "mean")

  optimize_positions:
    enabled: true              # true/false (outer loop moves coil centers to improve fit)
    movable_coils: "pf_only"    # pf_only | all | none | [ "PF1", "PF2", ... ] (which coils may move)

    vessel_avoidance:
      enabled: false
      clearance: 0.001

    R_bounds: [0.4, 3.0]        # [min,max] m (global fallback bounds for movable coil R)
    Z_bounds: [-1.7, 1.7]       # [min,max] m (global fallback bounds for movable coil Z)
    per_coil_bounds:
      PF1U:
        R: [0.55, 1.55]         # Rc = 1.05 ± 0.5
        Z: [0.60, 1.60]         # Zc = 1.10 ± 0.5

      PF1L:
        R: [0.45, 1.45]         # Rc = 0.95 ± 0.2
        Z: [-0.90, 0.10]       # Zc = -0.40 ± 0.2

      PF2U:
        R: [1.2, 2.20]         # Rc = 1.70 ± 0.2
        Z: [0.60, 1.60]         # Zc = 1.10 ± 0.2

      PF2L:
        R: [1.0, 2.00]         # Rc = 1.50 ± 0.2
        Z: [-1.55, -0.55]       # Zc = -1.05 ± 0.2

      PF3U:
        R: [1.90, 2.90]         # Rc = 2.40 ± 0.2
        Z: [-0.10, 0.90]         # Zc = 0.40 ± 0.2

      PF3L:
        R: [1.90, 2.90]         # Rc = 2.40 ± 0.2
        Z: [-0.90, 0.10]       # Zc = -0.40 ± 0.2

      PF4:
        R: [0.45, 1.45]         # Rc = 0.95 ± 0.2
        Z: [-0.10, 0.90]         # Zc = 0.40 ± 0.2

    max_iter: 4                # int (DE generations; more -> better, slower)
    population: 4               # int (DE popsize factor; more exploration, slower)
    seed: 2                     # int (reproducible randomness)
    polish: true                # true/false (final local refinement)

    psi_ref: 1.0                # float | omit (optional override used during position search)
    constraint: "mean"          # mean | omit (optional override used during position search)

    objective:
      w_contour: 1.0            # weight for contour_rms (main shape metric; lower better)
      w_xnorm: 0.0002             # weight for ||x||^2 (penalize large currents / authority use)
      w_clamp: 2.0              # weight for clamp count (penalize hitting bounds)
      w_move: 0.03               # weight for mean displacement^2 (penalize moving coils too far)

numerics:
  # Differencing choices
  finite_difference_order: 2
  # Handling near boundaries / smoothing
  smooth_jphi: false
  smooth_sigma: 0.0

output:
  # What to store
  store_iteration_history: true
  store_debug_arrays: false
